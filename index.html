<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Challenge 2026: Raise the Roof Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #95a5a6;
            border-radius: 4px;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 5px solid #e67e22;
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; color: #f1c40f; }
        p { margin: 5px 0; font-size: 16px; }
        .key {
            display: inline-block;
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            margin: 0 2px;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .btn {
            background: #e67e22;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: background 0.2s;
        }
        .btn:hover { background: #d35400; }
        .grade-btn { min-width: 200px; }
        .hidden { display: none !important; }
        #timer { font-size: 32px; font-weight: bold; color: #e74c3c; }
        #score { color: #2ecc71; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-panel">
            <h1>Raise the Roof 2026</h1>
            <p>Time: <span id="timer">04:00</span></p>
            <p>Placed: <span id="score">0/3</span></p>
            <p>Current Grade: <span id="grade-display">--</span></p>
        </div>
        <div class="hud-panel">
            <p><span class="key">←</span> <span class="key">→</span> Rotate Arm</p>
            <p><span class="key">↑</span> <span class="key">↓</span> Extend/Retract</p>
            <p><span class="key">SPACE</span> Lower/Raise Hook</p>
            <p><span class="key">G</span> Grab/Drop Module</p>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 48px; color: #f1c40f;">RAISE THE ROOF by ESHANZ</h1>
        <p style="font-size: 20px; max-width: 600px; text-align: center; margin-bottom: 30px;">
            Construct a lifting device to move housing modules from Zone 1 to the targets.<br>
            Select your Grade Level to determine the difficulty.
        </p>
        <button class="btn grade-btn" onclick="startGame(0)">Grades 4-5 (Easier)</button>
        <button class="btn grade-btn" onclick="startGame(1)">Grade 6 (Medium)</button>
        <button class="btn grade-btn" onclick="startGame(2)">Grades 7-8 (Hard)</button>
        <button class="btn grade-btn" onclick="startGame(3)">Grades 9-12 (Expert)</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="go-title">Mission Complete!</h1>
        <p id="go-message">You moved all modules safely.</p>
        <p>Final Time: <span id="go-time">00:00</span></p>
        <button class="btn" onclick="location.reload()">Try Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let gameState = 'MENU'; // MENU, PLAYING, END
    let lastTime = 0;
    let timeLeft = 240; // 4 minutes
    let gradeLevel = 0; // 0-3
    let placedCount = 0;

    // Constants (Scale: 1 unit = 1 inch approx, but scaled for screen)
    let SCALE = 1;
    let ORIGIN_X = 0;
    let ORIGIN_Y = 0;

    // Entities
    const modules = [];
    const targets = [];
    const crane = {
        angle: Math.PI / 2, // Facing up/forward
        length: 150,
        maxLength: 300,
        minLength: 50,
        height: 100, // Z-axis height (0-100)
        hookHeight: 100, // 100 = fully up, 0 = ground
        holding: null,
        x: 0,
        y: 0,
        tipX: 0,
        tipY: 0
    };

    // Inputs
    const keys = {
        ArrowLeft: false,
        ArrowRight: false,
        ArrowUp: false,
        ArrowDown: false,
        Space: false,
        KeyG: false
    };

    let keyGToggle = false; // Prevent rapid toggle

    // Grade Configuration
    // Zone 1: Start (Left)
    // Zone 2: Large Targets (Mid-Left)
    // Zone 3: Small Targets (Mid-Right)
    // Zone 4: Stack Targets (Right)
    const TARGET_TYPES = {
        LARGE: { radius: 35, color: '#9b59b6', scoreRadius: 35, type: 'large' }, // 10 inch dia
        SMALL: { width: 40, height: 25, color: '#e74c3c', scoreRadius: 20, type: 'small' }, // Rectangle
        STACK: { width: 15, height: 15, color: '#f39c12', scoreRadius: 10, type: 'stack' } // Precise pins
    };

    // Initial Setup based on rules
    function initLevel(grade) {
        modules.length = 0;
        targets.length = 0;
        placedCount = 0;
        timeLeft = 240;
        
        // Modules start in Zone 1 (Far Left arc)
        // We place them roughly at angle 150-170 degrees at distance ~200
        for(let i=0; i<3; i++) {
            modules.push({
                id: i,
                x: 0, 
                y: 0,
                angle: (150 + i * 12) * (Math.PI/180), // Polar coords for setup
                dist: 250,
                width: 30, // 7 inches scaled
                height: 15, // 3.5 inches scaled
                rotation: (150 + i * 12) * (Math.PI/180) + Math.PI/2,
                color: '#8e44ad', // Purple/Brown wood
                z: 0, // On ground
                placed: false
            });
            // Convert polar to cartesian for initial position
            let m = modules[i];
            m.x = Math.cos(m.angle) * m.dist;
            m.y = Math.sin(m.angle) * m.dist; // In canvas Y grows down, we'll flip logic in draw
        }

        // Target Setup based on Rules
        // Zone 2: ~110-135 deg
        // Zone 3: ~45-70 deg
        // Zone 4: ~10-35 deg
        
        const configs = [
            // G 4-5: 2 Large (Z2), 1 Small (Z3)
            [
                { type: 'LARGE', angle: 120, dist: 200 },
                { type: 'LARGE', angle: 135, dist: 250 },
                { type: 'SMALL', angle: 60, dist: 220 }
            ],
            // G 6: 1 Large (Z2), 2 Small (Z3)
            [
                { type: 'LARGE', angle: 125, dist: 220 },
                { type: 'SMALL', angle: 50, dist: 200 },
                { type: 'SMALL', angle: 70, dist: 240 }
            ],
            // G 7-8: 2 Small (Z3), 1 Stack (Z4)
            [
                { type: 'SMALL', angle: 50, dist: 210 },
                { type: 'SMALL', angle: 65, dist: 250 },
                { type: 'STACK', angle: 20, dist: 230 }
            ],
            // G 9-12: 1 Small (Z3), 2 Stack (Z4)
            [
                { type: 'SMALL', angle: 60, dist: 220 },
                { type: 'STACK', angle: 15, dist: 200 },
                { type: 'STACK', angle: 30, dist: 240 }
            ]
        ];

        const config = configs[grade];
        config.forEach(c => {
            const tType = TARGET_TYPES[c.type];
            targets.push({
                x: Math.cos(c.angle * Math.PI/180) * c.dist,
                y: Math.sin(c.angle * Math.PI/180) * c.dist, // Note: Y logic inverted later
                ...tType,
                occupied: false
            });
        });

        // Reset Crane
        crane.angle = Math.PI / 2; // Straight up visually
        crane.length = 150;
        crane.hookHeight = 100;
        crane.holding = null;
    }

    function startGame(grade) {
        gradeLevel = grade;
        initLevel(gradeLevel);
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        const gradeNames = ["Grades 4-5", "Grade 6", "Grades 7-8", "Grades 9-12"];
        document.getElementById('grade-display').innerText = gradeNames[grade];
        
        gameState = 'PLAYING';
        requestAnimationFrame(gameLoop);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ORIGIN_X = canvas.width / 2;
        ORIGIN_Y = canvas.height - 100; // Bottom center-ish
        SCALE = Math.min(canvas.width, canvas.height) / 800;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    window.addEventListener('keydown', e => {
        if(e.code === 'Space') keys.Space = true;
        if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
        
        // Toggle Grab
        if(e.code === 'KeyG') {
            if(!keyGToggle) {
                toggleGrab();
                keyGToggle = true;
            }
        }
    });

    window.addEventListener('keyup', e => {
        if(e.code === 'Space') keys.Space = false;
        if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
        if(e.code === 'KeyG') keyGToggle = false;
    });

    function toggleGrab() {
        if (crane.holding !== null) {
            // Drop
            const m = modules[crane.holding];
            m.z = 0; // Drop to ground
            
            // Check placement
            checkPlacement(m);
            
            crane.holding = null;
        } else {
            // Attempt Grab
            // Must be near ground (hookHeight < 10)
            if (crane.hookHeight > 10) return;

            // Find nearest module
            let bestDist = 20; // Grab radius
            let bestId = -1;

            modules.forEach(m => {
                const dx = m.x - crane.tipX;
                const dy = m.y - crane.tipY; // Canvas Y coordinates
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Canvas Y grows down. In our logic, positive Y is "up" on the schematic map,
                // but we render inverted. We need to be careful with coordinate spaces.
                // Let's stick to: Simulation logic uses X,Y relative to Origin.
                // Rendering handles the flip.
                
                if (dist < bestDist && !m.placed) {
                    bestId = m.id;
                }
            });

            if (bestId !== -1) {
                crane.holding = bestId;
            }
        }
    }

    function checkPlacement(module) {
        // Find if colliding with a valid target
        let hitTarget = false;
        
        targets.forEach(t => {
            if (t.occupied) return; // Already full

            const dx = module.x - t.x;
            const dy = module.y - t.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < t.scoreRadius) {
                // Success
                t.occupied = true;
                module.placed = true;
                // Snap to center
                module.x = t.x;
                module.y = t.y;
                module.rotation = 0; // Neaten up
                placedCount++;
                hitTarget = true;
            }
        });

        document.getElementById('score').innerText = `${placedCount}/3`;

        if (placedCount >= 3) {
            endGame(true);
        }
    }

    function endGame(win) {
        gameState = 'END';
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('go-title').innerText = win ? "CONSTRUCTION COMPLETE!" : "TIME UP!";
        document.getElementById('go-message').innerText = win ? "Great job raising the roof!" : "You didn't move all modules in time.";
        document.getElementById('go-time').innerText = document.getElementById('timer').innerText;
    }

    function update(dt) {
        if (gameState !== 'PLAYING') return;

        // Timer
        timeLeft -= dt;
        if (timeLeft <= 0) {
            timeLeft = 0;
            endGame(false);
        }
        
        const m = Math.floor(timeLeft / 60);
        const s = Math.floor(timeLeft % 60);
        document.getElementById('timer').innerText = `${m}:${s.toString().padStart(2, '0')}`;

        // Crane Movement
        const rotateSpeed = 1.5 * dt;
        const extendSpeed = 100 * dt;
        const winchSpeed = 80 * dt;

        if (keys.ArrowLeft) crane.angle += rotateSpeed;
        if (keys.ArrowRight) crane.angle -= rotateSpeed;
        
        // Clamp Angle (0 to 180 degrees)
        if (crane.angle > Math.PI) crane.angle = Math.PI;
        if (crane.angle < 0) crane.angle = 0;

        if (keys.ArrowUp) crane.length += extendSpeed;
        if (keys.ArrowDown) crane.length -= extendSpeed;

        // Clamp Length
        if (crane.length > crane.maxLength) crane.length = crane.maxLength;
        if (crane.length < crane.minLength) crane.length = crane.minLength;

        // Hook Height
        if (keys.Space) {
            crane.hookHeight -= winchSpeed; // Lower
        } else {
            crane.hookHeight += winchSpeed; // Auto Retract if not holding? No, let's make it manual or auto-up?
            // Let's make Space = Lower, Release Space = Raise
        }

        if (crane.hookHeight < 0) crane.hookHeight = 0;
        if (crane.hookHeight > 100) crane.hookHeight = 100;

        // Calculate Tip Position (Simulation Coords)
        // Angle 0 = Right, PI = Left, PI/2 = Top (Screen visual is top-down)
        // We map PI/2 to "Up" (-Y in canvas)
        crane.tipX = Math.cos(crane.angle) * crane.length;
        crane.tipY = Math.sin(crane.angle) * crane.length;

        // Update held module
        if (crane.holding !== null) {
            const mod = modules[crane.holding];
            mod.x = crane.tipX;
            mod.y = crane.tipY;
            mod.z = crane.hookHeight;
            mod.rotation = crane.angle + Math.PI/2; // Orient with crane
        }
    }

    function draw() {
        // Clear background
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Transform coordinate system
        // Move (0,0) to center bottom, Y points UP (visually)
        ctx.save();
        ctx.translate(ORIGIN_X, ORIGIN_Y);
        ctx.scale(SCALE, -SCALE); // Flip Y so positive is UP

        // Draw Work Area Zones
        // Semi-circle radius approx 350
        ctx.globalAlpha = 0.3;
        
        // Zone 1 (Left) - PI to 3PI/4
        ctx.fillStyle = '#e67e22'; // Orange
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 350, Math.PI * 0.75, Math.PI); ctx.fill();
        
        // Zone 2 - 3PI/4 to PI/2
        ctx.fillStyle = '#f1c40f'; // Yellow
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 350, Math.PI * 0.5, Math.PI * 0.75); ctx.fill();

        // Zone 3 - PI/2 to PI/4
        ctx.fillStyle = '#2ecc71'; // Green
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 350, Math.PI * 0.25, Math.PI * 0.5); ctx.fill();

        // Zone 4 - PI/4 to 0
        ctx.fillStyle = '#3498db'; // Blue
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 350, 0, Math.PI * 0.25); ctx.fill();

        // Draw Zone Labels (Text needs untransformed context or flip back)
        ctx.globalAlpha = 1.0;
        
        // Platform
        ctx.fillStyle = '#95a5a6';
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI * 2); // 24" diameter scaled
        ctx.fill();
        ctx.strokeStyle = '#7f8c8d';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw Targets
        targets.forEach(t => {
            ctx.fillStyle = t.occupied ? '#555' : t.color;
            if (t.type === 'large') {
                ctx.beginPath(); ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2); ctx.fill();
            } else if (t.type === 'small') {
                ctx.save();
                ctx.translate(t.x, t.y);
                ctx.fillRect(-t.width/2, -t.height/2, t.width, t.height);
                // Hole in middle
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(-t.width/4, -t.height/4, t.width/2, t.height/2);
                ctx.restore();
            } else if (t.type === 'stack') {
                ctx.save();
                ctx.translate(t.x, t.y);
                // Base
                ctx.fillRect(-t.width, -t.height, t.width*2, t.height*2);
                // Pins
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(5, 0, 3, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        });

        // Draw Modules
        modules.forEach(m => {
            ctx.save();
            ctx.translate(m.x, m.y);
            ctx.rotate(m.rotation);
            
            // Shadow (based on height)
            if (m.z > 5) {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                const shadowScale = 1 - (m.z/200);
                ctx.scale(shadowScale, shadowScale);
                ctx.fillRect(-m.width/2 + 5, -m.height/2 - 5, m.width, m.height);
                ctx.restore();
            }

            // Body
            ctx.fillStyle = m.color;
            ctx.fillRect(-m.width/2, -m.height/2, m.width, m.height);
            
            // Lifting eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(-m.width/3, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(m.width/3, 0, 2, 0, Math.PI*2); ctx.fill();

            // Highlight if held
            if (crane.holding === m.id) {
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 2;
                ctx.strokeRect(-m.width/2, -m.height/2, m.width, m.height);
            }
            
            ctx.restore();
        });

        // Draw Crane
        // Arm
        ctx.strokeStyle = '#34495e';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(crane.tipX, crane.tipY);
        ctx.stroke();

        // Central pivot cap
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath(); ctx.arc(0,0, 10, 0, Math.PI*2); ctx.fill();

        // Cable/String
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(crane.tipX, crane.tipY);
        // Visual Hook Height logic:
        // High hookHeight (100) = Short string (visual radius small? No top down)
        // Actually, top down, you can't see string length easily.
        // We will represent height by the size of the hook marker.
        ctx.lineTo(crane.tipX, crane.tipY); // Just a point top down
        ctx.stroke();

        // Hook / Magnet
        ctx.save();
        ctx.translate(crane.tipX, crane.tipY);
        
        // Scale hook based on height (closer = bigger)
        const hookScale = 0.5 + (100 - crane.hookHeight)/100; 
        ctx.scale(hookScale, hookScale);

        ctx.fillStyle = crane.holding !== null ? '#27ae60' : '#c0392b'; // Green if holding, Red if not
        ctx.beginPath();
        ctx.arc(0,0, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Height Indicator Ring
        ctx.strokeStyle = `rgba(255,255,255,${crane.hookHeight/100})`;
        ctx.beginPath();
        ctx.arc(0,0, 15, 0, Math.PI*2);
        ctx.stroke();
        
        ctx.restore();

        ctx.restore();

        // Text Overlay for Zones (Manual transform back roughly)
        ctx.save();
        ctx.font = "bold 16px Arial";
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fillText("ZONE 1", ORIGIN_X - 250 * SCALE, ORIGIN_Y - 100 * SCALE);
        ctx.fillText("ZONE 2", ORIGIN_X - 150 * SCALE, ORIGIN_Y - 250 * SCALE);
        ctx.fillText("ZONE 3", ORIGIN_X + 150 * SCALE, ORIGIN_Y - 250 * SCALE);
        ctx.fillText("ZONE 4", ORIGIN_X + 250 * SCALE, ORIGIN_Y - 100 * SCALE);
        
        // Hook Height Indicator Text near cursor
        const screenTipX = ORIGIN_X + crane.tipX * SCALE;
        const screenTipY = ORIGIN_Y - crane.tipY * SCALE; // Y flipped
        ctx.fillStyle = "white";
        ctx.font = "12px monospace";
        ctx.fillText(`H: ${Math.round(crane.hookHeight)}%`, screenTipX + 15, screenTipY - 15);
        ctx.restore();
    }

    function gameLoop(timestamp) {
        let dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if(dt > 0.1) dt = 0.1; // Cap dt

        update(dt);
        draw();

        if (gameState === 'PLAYING') {
            requestAnimationFrame(gameLoop);
        }
    }
</script>
</body>
</html>

