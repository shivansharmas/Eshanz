<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tech Challenge 2026: Raise the Roof by ESHANZ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #34495e 0%, #2c3e50 100%);
        }
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        #ui-layer {
            position: absolute;
            top: 160px;
            left: 20px;
            pointer-events: none;
            z-index: 5;
            transition: top 0.3s;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 5px solid #e67e22;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; color: #f1c40f; text-transform: uppercase; }
        p { margin: 5px 0; font-size: 16px; }
        .key {
            display: inline-block;
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            margin: 0 2px;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .btn {
            background: #e67e22;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: background 0.2s, transform 0.1s;
            font-weight: bold;
            min-width: 250px;
        }
        .btn:hover { background: #d35400; transform: scale(1.05); }
        .hidden { display: none !important; }
        #timer { font-size: 32px; font-weight: bold; color: #e74c3c; }
        #score { color: #2ecc71; font-weight: bold; }
        
        #message-toast {
            position: absolute;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }

        /* --- MOBILE CONTROLS (Default: Hidden) --- */
        .mobile-controls {
            display: none; /* Hidden by default on desktop */
            position: absolute;
            top: 10px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
        }

        .d-pad {
            position: relative;
            width: 150px;
            height: 150px;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            backdrop-filter: blur(2px);
        }
        .d-btn {
            position: absolute;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #555;
            border-radius: 8px;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            touch-action: none;
        }
        .d-btn:active { background: #e67e22; }
        /* D-Pad Positioning Calculation: Center (75) - HalfBtn (22.5) = 52.5 */
        .d-up { top: 5px; left: 52px; }
        .d-down { bottom: 5px; left: 52px; }
        .d-left { top: 52px; left: 5px; }
        .d-right { top: 52px; right: 5px; }

        .action-group {
            position: relative;
            width: 180px;
            height: 150px;
            pointer-events: auto;
            display: flex;
            align-items: flex-start;
            justify-content: flex-end;
            gap: 15px;
            padding-top: 10px;
        }
        .act-btn {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            user-select: none;
            touch-action: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .act-btn:active { transform: scale(0.95); opacity: 0.8; }
        
        .btn-hook { background: #e74c3c; width: 80px; height: 80px; font-size: 16px; margin-top: 10px;}
        .btn-grab { background: #2ecc71; margin-top: 25px; }
        .btn-view { 
            position: absolute; 
            bottom: 0; right: 0; 
            width: 50px; height: 50px; 
            background: #3498db; 
            font-size: 10px;
        }

        /* --- MEDIA QUERIES FOR MOBILE/TABLET --- */
        @media (max-width: 1024px) {
            /* Shrink HUD Text */
            #ui-layer { top: 120px; left: 10px; } /* Move up */
            .hud-panel { padding: 10px; margin-bottom: 5px; }
            h1 { font-size: 18px; margin-bottom: 5px; }
            #timer { font-size: 22px; }
            #score { font-size: 14px; }
            p { font-size: 12px; margin: 2px 0; }
            
            /* Shrink Controls */
            .mobile-controls { height: 120px; top: 10px; padding: 0 10px; }
            
            /* Smaller D-Pad (120px) */
            .d-pad { width: 120px; height: 120px; }
            .d-btn { width: 35px; height: 35px; font-size: 18px; border-radius: 6px; }
            /* New Center: 60px. HalfBtn: 17.5px. Offset: 42.5px */
            .d-up { top: 5px; left: 42px; }
            .d-down { bottom: 5px; left: 42px; }
            .d-left { top: 42px; left: 5px; }
            .d-right { top: 42px; right: 5px; }

            /* Smaller Action Buttons */
            .action-group { width: 140px; height: 120px; gap: 10px; }
            .act-btn { width: 50px; height: 50px; font-size: 11px; border-width: 2px; }
            .btn-hook { width: 60px; height: 60px; font-size: 13px; margin-top: 5px; }
            .btn-grab { margin-top: 15px; }
            .btn-view { width: 40px; height: 40px; bottom: 0; right: 0; font-size: 9px; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-panel">
            <h1>Raise the Roof by ESHANZ</h1>
            <p>Time: <span id="timer">04:00</span></p>
            <p>Placed: <span id="score">0/3</span></p>
            <p>Grade: <span id="grade-display">--</span></p>
        </div>
        <div class="hud-panel" id="controls-help" style="font-size: 0.8em; opacity: 0.8;">
            <p>‚å®Ô∏è Keyboard / üì± Touch</p>
            <p><span class="key">Arrows</span> Move</p>
            <p><span class="key">Space</span> Hook</p>
            <p><span class="key">G</span> Grab</p>
            <p><span class="key">V</span> View</p>
        </div>
    </div>
    
    <div id="message-toast">Message</div>

    <div class="mobile-controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp">‚¨ÜÔ∏è</div>
            <div class="d-btn d-left" data-key="ArrowLeft">‚¨ÖÔ∏è</div>
            <div class="d-btn d-right" data-key="ArrowRight">‚û°Ô∏è</div>
            <div class="d-btn d-down" data-key="ArrowDown">‚¨áÔ∏è</div>
        </div>
        <div class="action-group">
            <div class="act-btn btn-view" data-key="KeyV">VIEW</div>
            <div class="act-btn btn-grab" data-key="KeyG">GRAB</div>
            <div class="act-btn btn-hook" data-key="Space">HOOK</div>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 48px; color: #f1c40f; text-align:center;">RAISE THE ROOF by ESHANZ</h1>
        <p style="font-size: 20px; margin-bottom: 30px; color: #bdc3c7;">Select Difficulty Level</p>
        <button class="btn" onclick="startGame(0)">Grades 4-5 (2 Large, 1 Small)</button>
        <button class="btn" onclick="startGame(1)">Grade 6 (1 Large, 2 Small)</button>
        <button class="btn" onclick="startGame(2)">Grades 7-8 (2 Small, 1 Stack)</button>
        <button class="btn" onclick="startGame(3)">Grades 9-12 (1 Small, 2 Stack)</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="go-title">Mission Complete!</h1>
        <p id="go-message">You moved all modules safely.</p>
        <p>Final Time: <span id="go-time">00:00</span></p>
        <button class="btn" onclick="location.reload()">Try Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Constants & Config ---
    let currentViewScaleY = 0.6; // 0.6 for Iso
    let currentHeightScale = 1.0; 
    let viewRotationOffset = 0; 
    let viewMode = 0; 

    let SCALE = 1;
    let CENTER_X = 0;
    let CENTER_Y = 0;

    let gameState = 'MENU';
    let lastTime = 0;
    let timeLeft = 240;
    let placedCount = 0;
    
    const crane = {
        angle: Math.PI, // Start facing LEFT (Zone 1)
        length: 150,
        maxLength: 300,
        minLength: 50,
        hookHeight: 100, // 0 = floor, 100 = top
        holding: null,
        poleHeight: 140, 
        counterJibLength: 80
    };

    const modules = [];
    const targets = [];
    
    const hurdle = { angle: Math.PI/2, distStart: 50, distEnd: 350, height: 60 };

    const keys = { ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false, Space:false, KeyG:false, KeyV:false };
    let keyGToggle = false;
    let keyVToggle = false;

    // --- Device Detection ---
    function checkDevice() {
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // Check if screen is mobile/tablet size (<= 1024px)
        const isSmallScreen = window.innerWidth <= 1024;

        if (isTouch && isSmallScreen) {
            // Show Mobile Controls
            document.querySelector('.mobile-controls').style.display = 'flex';
            // Hide the Keyboard instructions to save space
            document.getElementById('controls-help').style.display = 'none';
        } else {
            document.querySelector('.mobile-controls').style.display = 'none';
            document.getElementById('controls-help').style.display = 'block';
        }
    }
    window.addEventListener('resize', checkDevice);
    // Run detection on load
    checkDevice();

    // --- Setup ---
    function initLevel(grade) {
        modules.length = 0;
        targets.length = 0;
        placedCount = 0;
        timeLeft = 240;
        
        crane.angle = Math.PI * 0.95; 
        crane.length = 150;
        crane.hookHeight = 100;
        crane.holding = null;

        for(let i=0; i<3; i++) {
            const angleDeg = 145 + (i * 12);
            const angle = angleDeg * (Math.PI/180);
            modules.push({
                id: i,
                angle: angle,
                dist: 280, 
                width: 30, height: 15,
                color: '#8e44ad',
                z: 0,
                placed: false
            });
        }

        const configs = [
            [ {t:'L', a:110, d:200}, {t:'L', a:130, d:250}, {t:'S', a:60, d:220} ],
            [ {t:'L', a:110, d:220}, {t:'S', a:55, d:200}, {t:'S', a:75, d:240} ],
            [ {t:'S', a:60, d:210}, {t:'S', a:80, d:250}, {t:'K', a:20, d:230} ],
            [ {t:'S', a:50, d:220}, {t:'K', a:15, d:200}, {t:'K', a:35, d:240} ]
        ];

        configs[grade].forEach(c => {
            targets.push({
                type: c.t,
                angle: c.a * (Math.PI/180),
                dist: c.d,
                occupied: false,
                x: Math.cos(c.a * (Math.PI/180)) * c.d,
                y: Math.sin(c.a * (Math.PI/180)) * c.d
            });
        });
    }

    function startGame(grade) {
        initLevel(grade);
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('grade-display').innerText = ["4-5", "6", "7-8", "HS"][grade];
        document.getElementById('score').innerText = "0/3";
        gameState = 'PLAYING';
        requestAnimationFrame(gameLoop);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        CENTER_X = canvas.width / 2;
        CENTER_Y = canvas.height * 0.75; 
        SCALE = Math.min(canvas.width, canvas.height) / 800;
        checkDevice(); // Re-check layout on resize
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('keydown', e => {
        if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = true;
        if(e.code === 'KeyG' && !keyGToggle) { toggleGrab(); keyGToggle = true; }
        if(e.code === 'KeyV' && !keyVToggle) { toggleView(); keyVToggle = true; }
    });
    window.addEventListener('keyup', e => {
        if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = false;
        if(e.code === 'KeyG') keyGToggle = false;
        if(e.code === 'KeyV') keyVToggle = false;
    });

    document.querySelectorAll('.d-btn, .act-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = true;
            if(key === 'KeyG' && !keyGToggle) { toggleGrab(); keyGToggle = true; }
            if(key === 'KeyV' && !keyVToggle) { toggleView(); keyVToggle = true; }
            btn.style.transform = "scale(0.9)";
            btn.style.backgroundColor = "rgba(255,255,255,0.3)";
        });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = false;
            if(key === 'KeyG') keyGToggle = false;
            if(key === 'KeyV') keyVToggle = false;
            btn.style.transform = "scale(1)";
            btn.style.backgroundColor = ""; 
        });
    });

    function toggleView() {
        viewMode = (viewMode + 1) % 3;
        if (viewMode === 0) {
            currentViewScaleY = 0.6; currentHeightScale = 1.0; viewRotationOffset = 0; showMessage("View: Isometric");
        } else if (viewMode === 1) {
            currentViewScaleY = 0.6; currentHeightScale = 1.0; viewRotationOffset = -Math.PI / 4; showMessage("View: Diagonal");
        } else {
            currentViewScaleY = 1.0; currentHeightScale = 0.0; viewRotationOffset = 0; showMessage("View: Top Down");
        }
    }

    function showMessage(msg, type='neutral') {
        const el = document.getElementById('message-toast');
        el.innerText = msg;
        el.style.color = type === 'good' ? '#2ecc71' : (type === 'bad' ? '#e74c3c' : 'white');
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 2000);
    }

    function toggleGrab() {
        if (crane.holding !== null) {
            // Drop logic
            // Check height safety first
            if (crane.hookHeight > 10) {
                showMessage("Hook too high to drop!", "bad");
                return;
            }

            const m = modules[crane.holding];
            m.z = 0;
            crane.holding = null;
            
            const dropX = Math.cos(m.angle) * m.dist;
            const dropY = Math.sin(m.angle) * m.dist;
            
            let placed = false;
            targets.forEach(t => {
                if(t.occupied || m.placed) return; 
                
                const dx = dropX - t.x;
                const dy = dropY - t.y; 
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                let limit = 20; 
                if(t.type === 'K') limit = 12; 

                if(dist < limit) {
                    t.occupied = true;
                    m.placed = true;
                    m.angle = Math.atan2(t.y, t.x);
                    m.dist = t.dist;
                    placedCount++;
                    document.getElementById('score').innerText = placedCount + "/3";
                    showMessage("Target Secured!", "good");
                    placed = true;
                    
                    if(placedCount >= 3) endGame(true);
                }
            });
            
            if(!placed) showMessage("Module Dropped");

        } else {
            if (crane.hookHeight > 10) {
                showMessage("Hook too high!", "bad");
                return;
            }

            const tipX = Math.cos(crane.angle) * crane.length;
            const tipY = Math.sin(crane.angle) * crane.length;

            let best = null;
            let minDist = 35; // Increased grab range slightly

            modules.forEach(m => {
                if(m.placed) return; 
                
                const mx = Math.cos(m.angle) * m.dist;
                const my = Math.sin(m.angle) * m.dist;

                const d = Math.sqrt(Math.pow(mx-tipX, 2) + Math.pow(my-tipY, 2));
                if(d < minDist) {
                    minDist = d;
                    best = m.id;
                }
            });

            if (best !== null) {
                crane.holding = best;
                showMessage("Module Grabbed!", "good");
            }
        }
    }

    function endGame(win, failureReason = "") {
        gameState = 'END';
        document.getElementById('game-over-screen').classList.remove('hidden');
        const title = document.getElementById('go-title');
        const msg = document.getElementById('go-message');
        if(win) {
            title.innerText = "MISSION COMPLETE!";
            title.style.color = "#2ecc71";
            msg.innerText = "Great work! All modules placed safely.";
        } else {
            title.innerText = "MISSION FAILED";
            title.style.color = "#e74c3c";
            msg.innerText = failureReason || "Time ran out.";
        }
        document.getElementById('go-time').innerText = document.getElementById('timer').innerText;
    }

    function update(dt) {
        if(gameState !== 'PLAYING') return;

        timeLeft -= dt;
        if(timeLeft <= 0) {
            timeLeft = 0;
            if(placedCount < 3) endGame(false);
            else endGame(true);
        }
        const m = Math.floor(timeLeft / 60);
        const s = Math.floor(timeLeft % 60);
        document.getElementById('timer').innerText = `${m}:${s.toString().padStart(2, '0')}`;

        const rotSpeed = 1.5 * dt;
        const extSpeed = 100 * dt;
        const liftSpeed = 80 * dt;

        if(keys.ArrowRight) crane.angle -= rotSpeed; 
        if(keys.ArrowLeft) crane.angle += rotSpeed;  
        
        if(crane.angle < 0) crane.angle = 0;
        if(crane.angle > Math.PI) crane.angle = Math.PI;

        if(keys.ArrowUp) crane.length += extSpeed;
        if(keys.ArrowDown) crane.length -= extSpeed;
        if(crane.length > crane.maxLength) crane.length = crane.maxLength;
        if(crane.length < crane.minLength) crane.length = crane.minLength;

        if(keys.Space) {
            crane.hookHeight -= liftSpeed;
        } else {
            crane.hookHeight += liftSpeed;
        }
        if(crane.hookHeight < 0) crane.hookHeight = 0;
        if(crane.hookHeight > 130) crane.hookHeight = 130; 

        // --- UPDATE HELD MODULE (Fixed: Must happen every frame) ---
        if(crane.holding !== null) {
            const mod = modules[crane.holding];
            mod.angle = crane.angle;
            mod.dist = crane.length;
            mod.z = crane.hookHeight;
        }

        // --- COLLISION DETECTION ---
        const currentX = Math.cos(crane.angle) * crane.length;
        const collisionThreshold = 10; 
        
        if (Math.abs(currentX) < collisionThreshold) {
            if (crane.length > hurdle.distStart && crane.length < hurdle.distEnd) {
                // Holding Module Check
                if (crane.holding !== null) {
                    const mod = modules[crane.holding];
                    if (mod.z < hurdle.height) {
                        endGame(false, "Mission Failed, Crane destroyed. Restart!");
                        return;
                    }
                } 
                // Just Hook Check
                else {
                    if (crane.hookHeight < hurdle.height) {
                        endGame(false, "Mission Failed, Crane destroyed. Restart!");
                        return;
                    }
                }
            }
        }
    }

    function project(angle, dist, height) {
        const effAngle = angle + viewRotationOffset;
        const x = Math.cos(effAngle) * dist;
        const y = Math.sin(effAngle) * dist; 
        return {
            x: CENTER_X + x * SCALE,
            y: CENTER_Y - (y * currentViewScaleY * SCALE) - (height * currentHeightScale * SCALE)
        };
    }
    
    function projectShadow(angle, dist) {
        const effAngle = angle + viewRotationOffset;
        const x = Math.cos(effAngle) * dist;
        const y = Math.sin(effAngle) * dist;
        return {
            x: CENTER_X + x * SCALE,
            y: CENTER_Y - (y * currentViewScaleY * SCALE)
        };
    }

    function draw() {
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        drawZone(Math.PI*0.75, Math.PI, '#e67e22', "Zone 1");
        drawZone(Math.PI*0.5, Math.PI*0.75, '#f1c40f', "Zone 2");
        drawZone(Math.PI*0.25, Math.PI*0.5, '#2ecc71', "Zone 3");
        drawZone(0, Math.PI*0.25, '#3498db', "Zone 4");
        
        drawPlatform();
        drawHurdle();
        targets.forEach(t => drawTarget(t));

        modules.forEach(m => drawModuleShadow(m));
        modules.forEach(m => drawModule(m));

        drawCrane(); 
        drawLabels();
    }

    function drawZone(startAngle, endAngle, color, label) {
        ctx.beginPath();
        const cx = CENTER_X;
        const cy = CENTER_Y;
        ctx.moveTo(cx, cy);
        for(let a = startAngle; a <= endAngle; a += 0.05) {
            const p = projectShadow(a, 350);
            ctx.lineTo(p.x, p.y);
        }
        ctx.lineTo(cx, cy);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function drawPlatform() {
        ctx.fillStyle = '#7f8c8d';
        ctx.beginPath();
        ctx.ellipse(CENTER_X, CENTER_Y, 50*SCALE, 50*currentViewScaleY*SCALE, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
    }

    function drawHurdle() {
        const startR = 50;
        const endR = 350;
        const radius = (endR - startR) / 2; 
        const centerDist = startR + radius; 
        const hurdleAngle = Math.PI / 2; 
        const heightScale = 60 / radius; 

        ctx.fillStyle = 'rgba(236, 240, 241, 0.5)';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const steps = 30;
        for (let i = 0; i <= steps; i++) {
            const t = (i / steps) * Math.PI; 
            const offset = Math.cos(t) * radius; 
            const h = Math.sin(t) * radius * heightScale;
            const p = project(hurdleAngle, centerDist - offset, h);
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        const startBase = project(hurdleAngle, startR, 0);
        const endBase = project(hurdleAngle, endR, 0);
        ctx.lineTo(startBase.x, startBase.y); 
        ctx.lineTo(endBase.x, endBase.y); 
        ctx.fill();
        ctx.stroke();
    }

    function drawTarget(t) {
        const p = project(t.angle, t.dist, 0);
        if (t.type === 'L') {
            ctx.fillStyle = t.occupied ? '#555' : 'rgba(155, 89, 182, 0.5)';
            ctx.beginPath();
            ctx.ellipse(p.x, p.y, 20*SCALE, 20*currentViewScaleY*SCALE, 0, 0, Math.PI*2);
            ctx.fill();
            if(t.occupied) ctx.stroke();
        } else if (t.type === 'S') {
            ctx.fillStyle = t.occupied ? '#555' : 'rgba(231, 76, 60, 0.5)';
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(-(t.angle + viewRotationOffset)); 
            ctx.fillRect(-15*SCALE, -10*SCALE, 30*SCALE, 20*SCALE);
            ctx.restore();
        } else if (t.type === 'K') {
            ctx.fillStyle = t.occupied ? '#555' : 'rgba(243, 156, 18, 0.8)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5*SCALE, 0, Math.PI*2);
            ctx.fill();
        }
    }

    function drawModuleShadow(m) {
        if(m.placed) return;
        const p = projectShadow(m.angle, m.dist);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, 15*SCALE, 8*SCALE, -(m.angle + viewRotationOffset), 0, Math.PI*2);
        ctx.fill();
    }

    function drawModule(m) {
        const p = project(m.angle, m.dist, m.z);
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(-(m.angle + viewRotationOffset)); 
        ctx.fillStyle = m.color;
        ctx.fillRect(-15*SCALE, -7.5*SCALE, 30*SCALE, 15*SCALE);
        ctx.fillStyle = '#9b59b6'; 
        ctx.beginPath();
        ctx.moveTo(-15*SCALE, -7.5*SCALE);
        ctx.lineTo(15*SCALE, -7.5*SCALE);
        ctx.lineTo(10*SCALE, -12*SCALE);
        ctx.lineTo(-20*SCALE, -12*SCALE);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-10*SCALE, -7.5*SCALE, 2*SCALE, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(10*SCALE, -7.5*SCALE, 2*SCALE, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    function drawTruss(startX, startY, endX, endY, width, color) {
        const dx = endX - startX;
        const dy = endY - startY;
        const len = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);

        ctx.save();
        ctx.translate(startX, startY);
        ctx.rotate(angle);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2 * SCALE;
        const halfW = width / 2;
        ctx.beginPath();
        ctx.moveTo(0, -halfW); ctx.lineTo(len, -halfW);
        ctx.moveTo(0, halfW); ctx.lineTo(len, halfW);
        ctx.stroke();
        ctx.lineWidth = 1 * SCALE;
        ctx.beginPath();
        const segs = 10;
        const segLen = len / segs;
        for(let i=0; i<segs; i++) {
            ctx.moveTo(i*segLen, -halfW);
            ctx.lineTo((i+1)*segLen, halfW);
            ctx.moveTo(i*segLen, halfW);
            ctx.lineTo((i+1)*segLen, -halfW);
        }
        ctx.stroke();
        ctx.restore();
    }

    function drawCrane() {
        const craneColor = '#f1c40f'; 
        const base = project(0, 0, 0); 
        const pivot = project(0, 0, crane.poleHeight); 

        const pivotShadow = project(0, 0, 0); 
        const tipShadow = project(crane.angle, crane.length, 0);
        const backTipShadow = project(crane.angle + Math.PI, crane.counterJibLength, 0);
        const hookShadow = project(crane.angle, crane.length, 0); 

        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        
        ctx.lineWidth = 15 * SCALE;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(pivotShadow.x, pivotShadow.y);
        ctx.lineTo(tipShadow.x, tipShadow.y);
        ctx.stroke();

        ctx.lineWidth = 12 * SCALE;
        ctx.beginPath();
        ctx.moveTo(pivotShadow.x, pivotShadow.y);
        ctx.lineTo(backTipShadow.x, backTipShadow.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.ellipse(pivotShadow.x, pivotShadow.y, 12*SCALE, 8*SCALE, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
        ctx.beginPath();
        ctx.ellipse(hookShadow.x, hookShadow.y, 8*SCALE, 4*SCALE, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const hookRealPos = project(crane.angle, crane.length, crane.hookHeight);
        ctx.moveTo(hookRealPos.x, hookRealPos.y);
        ctx.lineTo(hookShadow.x, hookShadow.y);
        ctx.stroke();
        ctx.restore();

        drawTruss(base.x, base.y, pivot.x, pivot.y, 15*SCALE, craneColor);

        const backTip = project(crane.angle + Math.PI, crane.counterJibLength, crane.poleHeight);
        drawTruss(pivot.x, pivot.y, backTip.x, backTip.y, 10*SCALE, craneColor);
        
        const cwPos = project(crane.angle + Math.PI, crane.counterJibLength - 10, crane.poleHeight);
        ctx.fillStyle = '#95a5a6'; 
        ctx.beginPath();
        ctx.ellipse(cwPos.x, cwPos.y, 10*SCALE, 15*SCALE, 0, 0, Math.PI*2);
        ctx.fill();

        const tip = project(crane.angle, crane.length, crane.poleHeight);
        drawTruss(pivot.x, pivot.y, tip.x, tip.y, 10*SCALE, craneColor);

        ctx.fillStyle = '#3498db';
        ctx.fillRect(pivot.x - 8*SCALE, pivot.y - 15*SCALE, 16*SCALE, 20*SCALE);

        const hookPos = project(crane.angle, crane.length, crane.hookHeight);
        ctx.strokeStyle = 'white'; 
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(tip.x, tip.y);
        ctx.lineTo(hookPos.x, hookPos.y);
        ctx.stroke();

        ctx.fillStyle = crane.holding !== null ? '#2ecc71' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(hookPos.x, hookPos.y, 5*SCALE, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(`H:${Math.round(crane.hookHeight)}`, hookPos.x + 10, hookPos.y);
    }

    function drawLabels() {
        ctx.font = "bold 16px Arial";
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.textAlign = "center";
        const p1 = project(Math.PI*0.875, 380, 0); ctx.fillText("ZONE 1", p1.x, p1.y);
        const p2 = project(Math.PI*0.625, 380, 0); ctx.fillText("ZONE 2", p2.x, p2.y);
        const p3 = project(Math.PI*0.375, 380, 0); ctx.fillText("ZONE 3", p3.x, p3.y);
        const p4 = project(Math.PI*0.125, 380, 0); ctx.fillText("ZONE 4", p4.x, p4.y);
    }

    function gameLoop(timestamp) {
        if(lastTime === 0) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        update(dt);
        draw();
        if(gameState === 'PLAYING') requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
